{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ObservableCollector.jl Easily define observables to be measured. Introduction Simulating a physical/biological/chemical,... system typically involes the following steps Setup a state with some initial conditions. Evole state through some deterministic or stochastic dynamics for a number of steps. Measure a host of observables; possibly only if some condition is fulfilled. Go back to 2. until the simulation reaches a halting condition. Step 3. typically involves preparing a vector for each quantity to be measured (or a dictionary) beforehand, and then pushing the measurements onto them. The package at hand implements a convinience layer around step 3. Terminology: state The current state of the model. Can be any data type or user defined structure. Contains all necessary information to determine observables from. observable Function of state and possibly simulation time. In the an observable will refer to a function f(state, time)::Any . Let us look at a quick (and mostly trivial) example. The state is simply a fixed-size vector. In each timestep we add a bit of random noise to every entry (effectively simulating many random walks on the real line). We'd like to measure mean and variance over time. Additionally we imagine the steps happening at rate 1.0 and thus draw the waiting-time between steps from an exponential distribution. using ObservableCollector using Distributions p = Gamma(100, 1.0) # sum of exponentially distr. rvs is gamma-distributed. state = fill(0.0, 1000) obs! = @observations begin @condition (s,t)- t%100==0 begin step -- (s,t)- t dt -- (s,t)- rand(p) m -- (s,t)- mean(s) var -- (s,t)- var(s) end end # note the ! in the name I chose. `obs!` will mutate its first argument. X = [] # empty array to store all measured quantities in. for t in 0:10^5 # make 10^5 steps obs!(X, state, t) state .+= 0.05*randn(length(state)) end X 4004-element Array{Any,1}: (name = :step, val = 0) (name = :dt, val = 105.37706326157641) (name = :m, val = 0.0) (name = :var, val = 0.0) (name = :step, val = 100) (name = :dt, val = 88.61881571895621) (name = :m, val = 0.0013903501549196913) (name = :var, val = 0.24051312705011824) (name = :step, val = 200) (name = :dt, val = 78.81074070971896) \u22ee (name = :var, val = 247.2311438331559) (name = :step, val = 99900) (name = :dt, val = 103.81942441462208) (name = :m, val = -0.623169733669445) (name = :var, val = 246.93783865577532) (name = :step, val = 100000) (name = :dt, val = 97.21619979062874) (name = :m, val = -0.6004513512721277) (name = :var, val = 246.63915399465546) This storage format is not very appealing. It is simply a linear record of observables collected throughout the run. We may use the timeseries function to cast it into a more useful form timeseries(X) Dict{Symbol,Any} with 4 entries: :m = Union{Missing, Float64}[0.0, 0.00139035, 0.0154984, 0.017198, 0.0296\u2026 :step = Union{Missing, Int64}[0, 100, 200, 300, 400, 500, 600, 700, 800, 900\u2026 :var = Union{Missing, Float64}[0.0, 0.240513, 0.453688, 0.724788, 1.01129, \u2026 :dt = Union{Missing, Float64}[105.377, 88.6188, 78.8107, 108.673, 112.357,\u2026 Hints t needn't necessarily be time. You may use it as some auxilliary variable, or even as a boolean switch to turn collection on/off. It also need not be a scalar, but could e.g. be a tuple. Observables are (by my definition) functions of state only and thus have no access to the measurement history. If you require observables to depend on previous measurements, store those in the state. ( TODO: example) Available methods # ObservableCollector.@observations Macro . @observations(block) Creates an anonymous function with arguments (output::Vector{Any}, state, time) that collects observables under conditions defined in block . Example: output = [] obs = @observations begin @condition (s,t)- t =3 begin A -- (s,t)- s T -- (s,t)- t end end for t in 1:4 obs(output,1,t) end julia @show output output = Any[(name = :A, val = 1), (name = :T, val = 3), (name = :A, val = 1), (name = :T, val = 4)] 4-element Array{Any,1}: (name = :A, val = 1) (name = :T, val = 3) (name = :A, val = 1) (name = :T, val = 4) source # ObservableCollector.@condition Macro . @condition(cond, block) Define multiple observables to be evaluated under the same condition. Use -- to define pairs of name -- map . Example @condition (s,t)- t =3 begin S -- (s,t)- s^2 T -- (s,t)- t end source @condition(cond, name, map) Creates a clause to collect an observable map(state,time) called name under condition cond(state,time) . See also: @at , @every source # ObservableCollector.@at Macro . @at(N::Integer, name, map) Creates a clause to collect an observable map(state,time) called name at timestep N . See also: @condition source # ObservableCollector.@every Macro . @every(N::Integer, name, map) Creates a clause to collect an observable map(state,time) called name every N timesteps, i.e t%N==0 . See also: @condition source # ObservableCollector.timeseries Function . timeseries(x) Turn a series of named tuples (name=x, val=y) into a dictionary with one series for each name . Types are Union{Missing, T} where T is the type of the first value encountered for a given name. source","title":"Home"},{"location":"#observablecollectorjl","text":"Easily define observables to be measured.","title":"ObservableCollector.jl"},{"location":"#introduction","text":"Simulating a physical/biological/chemical,... system typically involes the following steps Setup a state with some initial conditions. Evole state through some deterministic or stochastic dynamics for a number of steps. Measure a host of observables; possibly only if some condition is fulfilled. Go back to 2. until the simulation reaches a halting condition. Step 3. typically involves preparing a vector for each quantity to be measured (or a dictionary) beforehand, and then pushing the measurements onto them. The package at hand implements a convinience layer around step 3. Terminology: state The current state of the model. Can be any data type or user defined structure. Contains all necessary information to determine observables from. observable Function of state and possibly simulation time. In the an observable will refer to a function f(state, time)::Any . Let us look at a quick (and mostly trivial) example. The state is simply a fixed-size vector. In each timestep we add a bit of random noise to every entry (effectively simulating many random walks on the real line). We'd like to measure mean and variance over time. Additionally we imagine the steps happening at rate 1.0 and thus draw the waiting-time between steps from an exponential distribution. using ObservableCollector using Distributions p = Gamma(100, 1.0) # sum of exponentially distr. rvs is gamma-distributed. state = fill(0.0, 1000) obs! = @observations begin @condition (s,t)- t%100==0 begin step -- (s,t)- t dt -- (s,t)- rand(p) m -- (s,t)- mean(s) var -- (s,t)- var(s) end end # note the ! in the name I chose. `obs!` will mutate its first argument. X = [] # empty array to store all measured quantities in. for t in 0:10^5 # make 10^5 steps obs!(X, state, t) state .+= 0.05*randn(length(state)) end X 4004-element Array{Any,1}: (name = :step, val = 0) (name = :dt, val = 105.37706326157641) (name = :m, val = 0.0) (name = :var, val = 0.0) (name = :step, val = 100) (name = :dt, val = 88.61881571895621) (name = :m, val = 0.0013903501549196913) (name = :var, val = 0.24051312705011824) (name = :step, val = 200) (name = :dt, val = 78.81074070971896) \u22ee (name = :var, val = 247.2311438331559) (name = :step, val = 99900) (name = :dt, val = 103.81942441462208) (name = :m, val = -0.623169733669445) (name = :var, val = 246.93783865577532) (name = :step, val = 100000) (name = :dt, val = 97.21619979062874) (name = :m, val = -0.6004513512721277) (name = :var, val = 246.63915399465546) This storage format is not very appealing. It is simply a linear record of observables collected throughout the run. We may use the timeseries function to cast it into a more useful form timeseries(X) Dict{Symbol,Any} with 4 entries: :m = Union{Missing, Float64}[0.0, 0.00139035, 0.0154984, 0.017198, 0.0296\u2026 :step = Union{Missing, Int64}[0, 100, 200, 300, 400, 500, 600, 700, 800, 900\u2026 :var = Union{Missing, Float64}[0.0, 0.240513, 0.453688, 0.724788, 1.01129, \u2026 :dt = Union{Missing, Float64}[105.377, 88.6188, 78.8107, 108.673, 112.357,\u2026","title":"Introduction"},{"location":"#hints","text":"t needn't necessarily be time. You may use it as some auxilliary variable, or even as a boolean switch to turn collection on/off. It also need not be a scalar, but could e.g. be a tuple. Observables are (by my definition) functions of state only and thus have no access to the measurement history. If you require observables to depend on previous measurements, store those in the state. ( TODO: example)","title":"Hints"},{"location":"#available-methods","text":"# ObservableCollector.@observations Macro . @observations(block) Creates an anonymous function with arguments (output::Vector{Any}, state, time) that collects observables under conditions defined in block . Example: output = [] obs = @observations begin @condition (s,t)- t =3 begin A -- (s,t)- s T -- (s,t)- t end end for t in 1:4 obs(output,1,t) end julia @show output output = Any[(name = :A, val = 1), (name = :T, val = 3), (name = :A, val = 1), (name = :T, val = 4)] 4-element Array{Any,1}: (name = :A, val = 1) (name = :T, val = 3) (name = :A, val = 1) (name = :T, val = 4) source # ObservableCollector.@condition Macro . @condition(cond, block) Define multiple observables to be evaluated under the same condition. Use -- to define pairs of name -- map . Example @condition (s,t)- t =3 begin S -- (s,t)- s^2 T -- (s,t)- t end source @condition(cond, name, map) Creates a clause to collect an observable map(state,time) called name under condition cond(state,time) . See also: @at , @every source # ObservableCollector.@at Macro . @at(N::Integer, name, map) Creates a clause to collect an observable map(state,time) called name at timestep N . See also: @condition source # ObservableCollector.@every Macro . @every(N::Integer, name, map) Creates a clause to collect an observable map(state,time) called name every N timesteps, i.e t%N==0 . See also: @condition source # ObservableCollector.timeseries Function . timeseries(x) Turn a series of named tuples (name=x, val=y) into a dictionary with one series for each name . Types are Union{Missing, T} where T is the type of the first value encountered for a given name. source","title":"Available methods"}]}